//= depend_on_asset 'markers/marker_large.png'
//= depend_on_asset 'markers/marker_small.png'
//= depend_on_asset 'markers/marker_large_spiderfied.png'
//= depend_on_asset 'markers/marker_small_spiderfied.png'
// Manages search results view Google Map.
define(['util/bitmask','domReady!',
				'async!https://maps.googleapis.com/maps/api/js?v=3.exp&sensor=false!callback'], function (bitmask) {
  'use strict';

  require(['spiderfier','https://google-maps-utility-library-v3.googlecode.com/svn/trunk/infobox/src/infobox_packed.js'],
    function() {

    // PRIVATE PROPERTIES
    // The <div> element that the Google map loads into.
    var _map;

    // The parent HTML element of the map.
    var _mapCanvas;

    // The element that controls the expanding/contracting of the map.
    var _mapViewControl;

    // Whether the map is at its max size or not.
    var _atMaxSize = false;

    // Parsed JSON object of map marker data (positioning, label, etc.).
    var _markerData;

    // The collective map bounds of the markers.
    var _markerBounds;

    // Array of markers on the map.
    var _markerList = [];

    // "Constants" for map button text content.
    var LARGER_MAP_TEXT = "<i class='fa fa-minus-square'></i> Smaller map";
    var SMALLER_MAP_TEXT = "<i class='fa fa-plus-square'></i> Larger map";

    var LARGE_MARKER_URL = "<%= asset_path('markers/marker_large.png') %>";
    var SMALL_MARKER_URL = "<%= asset_path('markers/marker_small.png') %>";

    var LARGE_SPIDERFY_MARKER_URL = "<%= asset_path('markers/marker_large_spiderfied.png') %>";
    var SMALL_SPIDERFY_MARKER_URL = "<%= asset_path('markers/marker_small_spiderfied.png') %>";

    // The spiderfier layer for handling overlapping markers.
    // See https://github.com/jawj/OverlappingMarkerSpiderfier
    var _spiderfier;

    // The info box to pop up when rolling over a marker.
    var _infoBox;

    // "Constant" for delay when showing/hiding the marker info box.
    var DEFAULT_INFOBOX_DELAY = 400;

    // A bitmask instance for tracking the different states of the infobox.
    var _infoBoxState;

    // The possible conditions that determine the infobox's behavior.
    var SHOW_INFOBOX = 1;
    var OVER_INFOBOX = 2;
    var OVER_MARKER = 4;
    var PIN_INFOBOX = 8;
    var HAS_SPIDERFIED = 16;

    // The timer for delaying the info box display.
    var _infoBoxDelay;

    // The marker that is currently clicked.
    var _selectedMarker;

    // The marker the cursor is currently over.
    var _overMarker;

    // The marker InfoBox content that is currently showing.
    var _infoBoxContent;

    // PUBLIC METHODS
    function init()
    {
      _infoBoxState = bitmask.create();

      // Only check for result map if the page isn't showing the no search results view.
      var noResults = document.querySelector("#results-entries .no-results");
      if (!noResults)
      {
        var mapContainer = document.getElementById('map-view');
        if (mapContainer)
        {
          _mapCanvas = document.getElementById("map-canvas");
          _mapViewControl = document.getElementById('map-view-control');
          _mapViewControl.innerHTML = SMALLER_MAP_TEXT;

          // Turns off Google Points-Of-Interest (POI) markers so the user
          // doesn't click a POI and get an infowindow popped up.
          var poiStyles =[
              {
                  featureType: "poi",
                  elementType: "labels",
                  stylers: [
                        { visibility: "off" }
                  ]
              }
          ];

          var mapOptions = {
            zoom: 15,
            scrollwheel: false,
            zoomControl: true,
            panControl: false,
            streetViewControl: false,
            scaleControl: true,
            scaleControlOptions: {
              position: google.maps.ControlPosition.RIGHT_BOTTOM
            },
            mapTypeControl: false,
            mapTypeId: google.maps.MapTypeId.ROADMAP,
            styles: poiStyles
          };

          var spiderfierOptions = {
            legWeight: 2,
            keepSpiderfied: true,
            nearbyDistance: 40
          };

          var infoBoxOptions = {
            disableAutoPan: false,
            pixelOffset: new google.maps.Size(7, -7),
            zIndex: null,
            infoBoxClearance: new google.maps.Size(1, 1),
            isHidden: false,
            closeBoxURL: '',
            enableEventPropagation: false
          };

          _map = new google.maps.Map(_mapCanvas, mapOptions);
          _spiderfier = new OverlappingMarkerSpiderfier(_map, spiderfierOptions);
          _infoBox = new InfoBox(infoBoxOptions);

          google.maps.event.addListener(_map, 'idle', _mapIdle);
          _mapViewControl.addEventListener('click', _mapViewControlClicked, false);

          _loadMarkers();
          _refresh();
        }
        else
        {
          console.log("Warning: The result map container was not found!");
        }
      }
    }

    // Event handler for when the map is idle. This is used by the spiderfier
    // to style the map markers that will spiderfy when clicked.
    function _mapIdle() {
      _styleSpiderfiedMarkers();
      google.maps.event.addListener(_map, 'zoom_changed', _mapZoomed);
      // Remove idle listeners as they aren't needed after the spiderfied markers
      // are styled for the first time.
      google.maps.event.clearListeners(_map, 'idle');
    }

    // Event handler for when the map is zoomed. This is used by the spiderfier
    // to handle style changes to the map markers that will spiderfy when clicked.
    function _mapZoomed() {
      _styleSpiderfiedMarkers();
    }

    // Run through the markers and set them to a spiderfied large or small
    // appearance based on the size of the map.
    function _styleSpiderfiedMarkers() {
      var markers = _spiderfier.getMarkers();
      var index = markers.length-1;
      while(index>=0) {
        if (_atMaxSize) markers[index--].setIcon(LARGE_MARKER_URL);
        else            markers[index--].setIcon(SMALL_MARKER_URL);
      }
      markers = _spiderfier.markersNearAnyOtherMarker();
      index = markers.length-1;
      while(index>=0) {
        if (_atMaxSize) markers[index--].setIcon(LARGE_SPIDERFY_MARKER_URL);
        else            markers[index--].setIcon(SMALL_SPIDERFY_MARKER_URL);
      }
    }

    // Map view control was clicked. This control toggles the large and small maps.
    function _mapViewControlClicked(evt) {
      if (_atMaxSize)
      {
        _mapCanvas.classList.remove('max');
        _mapViewControl.innerHTML = SMALLER_MAP_TEXT;
        _atMaxSize = false;
        _updateMarkerSizes();
      }
      else
      {
        _mapCanvas.classList.add('max');
        _mapViewControl.innerHTML = LARGER_MAP_TEXT;
        _atMaxSize = true;
        _updateMarkerSizes();
      }
      _refresh();

      evt.preventDefault();
    }

    // Loads the map markers.
    function _loadMarkers()
    {
      var locations = document.getElementById("map-locations");
      if (locations)
      {
        // Load the map marker data from the JSON map data embedded in the DOM.
        _markerData = JSON.parse(locations.innerHTML);

        // Remove the script element from the DOM
        locations.parentNode.removeChild(locations);
        _markerBounds = new google.maps.LatLngBounds();

        var index = _markerData.length-1;
        var marker;
        while(index>=0)
        {
          marker = _loadMarker( _markerData[index--] );
        }

        _overMarker = marker;

        // Register events for info box interactivity.
        google.maps.event.addListener(_infoBox, 'domready', function() {
          var contentDiv = _mapCanvas.querySelector('.infoBox');
          var buttonClose = contentDiv.querySelector('.button-close');
          contentDiv.addEventListener('mousemove', _overInfoBoxHandler, false);
          contentDiv.addEventListener('mouseleave', _leaveInfoBoxHandler, false);
          buttonClose.addEventListener('mousedown', _closeInfoBoxHandler, false);
        });
      }
    }

    function _overInfoBoxHandler(evt) {
      _infoBoxState.turnOn(OVER_INFOBOX);
      _updateInfoBoxState();
    }

    function _leaveInfoBoxHandler(evt) {
      _infoBoxState.turnOff(OVER_INFOBOX);
      _updateInfoBoxState();
    }

    function _closeInfoBoxHandler(evt) {
      _infoBoxState.turnOff(OVER_INFOBOX);
      _infoBoxState.turnOff(SHOW_INFOBOX);
      _infoBoxState.turnOff(PIN_INFOBOX);
      _updateInfoBoxState(0);
    }

    function _updateInfoBoxState(delay) {

      // Clear any transitions in progress.
      if (_infoBoxDelay) clearTimeout(_infoBoxDelay);

      // If delay is not set use the default delay value.
      var setDelay = delay !== undefined ? delay : DEFAULT_INFOBOX_DELAY;

      if ( _infoBoxState.isOn(OVER_MARKER) ) {
        if ( _infoBoxState.isOff(SHOW_INFOBOX) ) {
          _openInfoBox(setDelay);
        }
        else if (_infoBox.getContent() !== _infoBoxContent ) {
          _openInfoBox(setDelay);
        }
      }
      else if ( _infoBoxState.isOff(PIN_INFOBOX) &&
                _infoBoxState.isOff(OVER_INFOBOX) &&
                _infoBoxState.isOff(OVER_MARKER) )  {
        _closeInfoBox(setDelay);
      }
    }

    // Updates the marker icons to the size set for the map.
    function _updateMarkerSizes() {
      var index = _markerList.length-1;
      while(index>=0) {
        if (_atMaxSize)
          _markerList[index--].setIcon(LARGE_MARKER_URL);
        else
          _markerList[index--].setIcon(SMALL_MARKER_URL);
      }
    }

    // Load a single map marker.
    // @returns [Object] A google.maps.Marker instance that was created.
    function _loadMarker(markerData)
    {
      if (markerData['latitude'] && markerData['longitude'])
      {
        var myLatLng = new google.maps.LatLng(markerData['latitude'], markerData['longitude']);

        var markerIcon;
        if (_atMaxSize)
        {
          markerIcon = LARGE_MARKER_URL;
        }
        else
        {
          markerIcon = SMALL_MARKER_URL;
        }

        var marker = new google.maps.Marker({
          map: _map,
          position: myLatLng,
          icon: markerIcon,
          optimized: false
        });

        _markerList.push(marker);
        _spiderfier.addMarker(marker);

        var mainName = markerData.name;
        var orgName = markerData.org_name;
        if (orgName != markerData.name) {
         var agency = "<h2>"+orgName+"</h2>";
        }
        var content = "<div><div class='button-close'></div>"+
                      "<h1>"+mainName+"</h1>"+agency+
                      "<p>"+markerData.street_address+", "+markerData.city+"</p>"+
                      "<p><a href='/organizations/"+markerData.slug+(window.location.search)+
                      "'>View more details…</a></p></div>";

        _makeInfoBoxEvent(marker, content);

        _markerBounds.extend(myLatLng);
      }

      return marker;
    }

    // Open the global info box after a delay.
    // @param delay [Number] Delay in milliseconds before opening the info box.
    // If not specified, the delay will be the DEFAULT_INFOBOX_DELAY value.
    function _openInfoBox(delay)
    {
      _infoBoxDelay = setTimeout(function() {
        _infoBox.setContent(_infoBoxContent);
        _infoBox.open(_map, _selectedMarker);
        _infoBoxState.turnOn(SHOW_INFOBOX);
      }, delay);
    }

    // Open the global info box after a delay.
    // @param delay [Number] Delay in milliseconds before closing the info box.
    // If not specified, the delay will be the DEFAULT_INFOBOX_DELAY value.
    function _closeInfoBox(delay)
    {
      _infoBoxDelay = setTimeout(function() {
        _infoBox.close();
        _infoBoxState.turnOff(SHOW_INFOBOX);
      }, delay);
    }

    // Make info box events associated with a map marker.
    // @param marker [Object] The marker that triggered the opening of the info box.
    // @param content [String] The text content of the info box.
    function _makeInfoBoxEvent(marker, content) {

      google.maps.event.addListener(marker, 'mouseover', function() {
        if (marker.getIcon() !== SMALL_SPIDERFY_MARKER_URL) {
          if (_overMarker !== marker) _infoBoxState.turnOff(PIN_INFOBOX);
          _registerMarker(marker,content);
        }
      });

      google.maps.event.addListener(marker, 'mouseout', function() {
        _infoBoxState.turnOff(OVER_MARKER);
        _updateInfoBoxState();
      });

      // Change marker icon appearances when the markers spiderfy.
      _spiderfier.addListener('spiderfy', function(spiderfied,unspiderfied){
        _infoBoxState.turnOn(HAS_SPIDERFIED);
        var index = spiderfied.length-1;
        while(index>=0) {
          if (_atMaxSize) spiderfied[index--].setIcon(LARGE_MARKER_URL);
          else spiderfied[index--].setIcon(SMALL_MARKER_URL);
        }
      });

      // Change marker icon appearances when the markers unspiderfy.
      _spiderfier.addListener('unspiderfy', function(spiderfied,unspiderfied){
        var index = spiderfied.length-1;
        while(index>=0) {
          if (_atMaxSize) spiderfied[index--].setIcon(LARGE_SPIDERFY_MARKER_URL);
          else spiderfied[index--].setIcon(SMALL_SPIDERFY_MARKER_URL);
        }
      });

      // When user clicks the marker, open the infoBox and center the map on the marker.
      // Unless the user clicked a marker that just spiderfied.
      google.maps.event.addListener(marker, 'click', function() {

        if (_infoBoxState.isOff(HAS_SPIDERFIED)) {

          // Touch displays don't know they're over a marker till it's tapped,
          // so manually register the state as being over the marker in this case.
          if (_infoBoxState.isOff(OVER_MARKER)) _registerMarker(marker,content);

          // Toggle between pinning the infobox and closing it.
          if (_infoBoxState.isOn(PIN_INFOBOX))
          {
            _infoBoxState.turnOff(SHOW_INFOBOX);
            _infoBoxState.turnOff(PIN_INFOBOX);
            _infoBoxState.turnOff(OVER_MARKER);
            _updateInfoBoxState(0);
          }
          else
          {
            _map.panTo(marker.position);
            _infoBoxState.turnOn(PIN_INFOBOX);
            _infoBoxState.turnOn(OVER_MARKER);
            _updateInfoBoxState(0);
          }
        }
        else {
          _infoBoxState.turnOff(HAS_SPIDERFIED)
        }
      });
    }

    // Register a marker as having been clicked.
    // @param marker [Object] The marker that was clicked.
    // @param content [String] The text content of the infobox for this marker.
    function _registerMarker(marker, content)
    {
      _overMarker = marker;
      _infoBoxState.turnOn(OVER_MARKER);
      _infoBoxContent = content;
      _selectedMarker = marker;
      _updateInfoBoxState();
    }

    // Triggers a resize event and refits the map to the bounds of the markers
    function _refresh()
    {
      google.maps.event.trigger(_map, "resize");
      _map.fitBounds(_markerBounds);
    }

    // Makes the module initialization self-executing once dependencies have loaded.
    init();
  });

});
